// SPDX-FileCopyrightText: 2024 Demerzel Solutions Limited
// SPDX-License-Identifier: MIT

// Modification of original file generated by: https://github.com/supranational/blst/blob/master/bindings/c%23/run.me
// Copyright Supranational LLC
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

using System;
using System.Text;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Reflection;
using System.IO;
using size_t = nuint;

namespace Nethermind.Crypto;

public static partial class Bls
{
    private const string LibraryName = "blst";

    static Bls() => NativeLibrary.SetDllImportResolver(Assembly.GetExecutingAssembly(), LoadLibrary);

    private static nint LoadLibrary(string libraryName, Assembly assembly, DllImportSearchPath? searchPath)
    {
        string platform;

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            libraryName = $"lib{libraryName}.so";
            platform = "linux";
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            libraryName = $"{libraryName}.dll";
            platform = "win";
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            libraryName = $"lib{libraryName}.dylib";
            platform = "osx";
        }
        else
        {
            throw new PlatformNotSupportedException();
        }

        if (NativeLibrary.TryLoad(libraryName, assembly, searchPath, out var handle))
        {
            return handle;
        }

        var arch = RuntimeInformation.ProcessArchitecture.ToString().ToLowerInvariant();
        var path = Path.Combine("runtimes", $"{platform}-{arch}", "native", libraryName);
        return NativeLibrary.Load(path, assembly, searchPath);
    }

    public enum ERROR
    {
        SUCCESS = 0,
        BADENCODING,
        POINTNOTONCURVE,
        POINTNOTINGROUP,
        AGGRTYPEMISMATCH,
        VERIFYFAIL,
        PKISINFINITY,
        BADSCALAR,
        WRONGSIZE,
    }

    public class BlsException(ERROR err) : ApplicationException
    {
        private readonly ERROR code = err;

        public override string Message
        {
            get => code switch
            {
                ERROR.BADENCODING => "bad encoding",
                ERROR.POINTNOTONCURVE => "point not on curve",
                ERROR.POINTNOTINGROUP => "point not in group",
                ERROR.AGGRTYPEMISMATCH => "aggregate type mismatch",
                ERROR.VERIFYFAIL => "verify failure",
                ERROR.PKISINFINITY => "public key is infinity",
                ERROR.BADSCALAR => "bad scalar",
                _ => "",
            };
        }
    }

    public enum ByteOrder
    {
        BigEndian,
        LittleEndian
    }

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_keygen(Span<byte> key, ReadOnlySpan<byte> IKM, size_t IKM_len,
                                       ReadOnlySpan<byte> info, size_t info_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_keygen_v3(Span<byte> key, ReadOnlySpan<byte> IKM, size_t IKM_len,
                                          ReadOnlySpan<byte> info, size_t info_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_keygen_v4_5(Span<byte> key, ReadOnlySpan<byte> IKM, size_t IKM_len,
                                            ReadOnlySpan<byte> salt, size_t salt_len,
                                            ReadOnlySpan<byte> info, size_t info_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_keygen_v5(Span<byte> key, ReadOnlySpan<byte> IKM, size_t IKM_len,
                                          ReadOnlySpan<byte> salt, size_t salt_len,
                                          ReadOnlySpan<byte> info, size_t info_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_derive_master_eip2333(Span<byte> key,
                                                  ReadOnlySpan<byte> IKM, size_t IKM_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_derive_child_eip2333(Span<byte> key,
                                                 ReadOnlySpan<byte> master, uint child_index);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_scalar_from_bendian(Span<byte> ret, ReadOnlySpan<byte> key);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_bendian_from_scalar(Span<byte> ret, ReadOnlySpan<byte> key);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_sk_check(ReadOnlySpan<byte> key);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_scalar_from_lendian(Span<byte> key, ReadOnlySpan<byte> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_lendian_from_scalar(Span<byte> key, ReadOnlySpan<byte> inp);

    public readonly ref struct SecretKey
    {
        public readonly ReadOnlySpan<byte> Key { get => _key; }
        private readonly Span<byte> _key;

        public SecretKey(Span<byte> key)
        {
            if (key.Length < 32)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _key = key[..32];
        }

        public SecretKey() : this(new byte[32])
        {}

        public SecretKey(scoped ReadOnlySpan<byte> IKM, string info) : this()
            => Keygen(IKM, info);
        public SecretKey(scoped ReadOnlySpan<byte> inp, ByteOrder order = ByteOrder.BigEndian) : this()
        {
            switch (order)
            {
                case ByteOrder.BigEndian: FromBendian(inp); break;
                case ByteOrder.LittleEndian: FromLendian(inp); break;
            }
        }

        public readonly void Keygen(scoped ReadOnlySpan<byte> IKM, string info = "")
        {
            ReadOnlySpan<byte> info_bytes = Encoding.UTF8.GetBytes(info);
            blst_keygen(_key, IKM, (size_t)IKM.Length,
                             info_bytes, (size_t)info_bytes.Length);
        }
        public readonly void KeygenV3(scoped ReadOnlySpan<byte> IKM, string info = "")
        {
            ReadOnlySpan<byte> info_bytes = Encoding.UTF8.GetBytes(info);
            blst_keygen_v3(_key, IKM, (size_t)IKM.Length,
                                info_bytes, (size_t)info_bytes.Length);
        }
        public readonly void KeygenV45(scoped ReadOnlySpan<byte> IKM, string salt, string info = "")
        {
            ReadOnlySpan<byte> salt_bytes = Encoding.UTF8.GetBytes(salt);
            ReadOnlySpan<byte> info_bytes = Encoding.UTF8.GetBytes(info);
            blst_keygen_v4_5(_key, IKM, (size_t)IKM.Length,
                                  salt_bytes, (size_t)salt_bytes.Length,
                                  info_bytes, (size_t)info_bytes.Length);
        }
        public readonly void KeygenV5(scoped ReadOnlySpan<byte> IKM, scoped ReadOnlySpan<byte> salt, string info = "")
        {
            ReadOnlySpan<byte> info_bytes = Encoding.UTF8.GetBytes(info);
            blst_keygen_v5(_key, IKM, (size_t)IKM.Length,
                                salt, (size_t)salt.Length,
                                info_bytes, (size_t)info_bytes.Length);
        }
        public readonly void KeygenV5(scoped ReadOnlySpan<byte> IKM, string salt, string info = "")
            => KeygenV5(IKM, Encoding.UTF8.GetBytes(salt), info);
        public readonly void DeriveMasterEip2333(scoped ReadOnlySpan<byte> IKM)
            => blst_derive_master_eip2333(_key, IKM, (size_t)IKM.Length);
        public SecretKey(SecretKey master, uint childIndex)
        {
            _key = new byte[32];
            blst_derive_child_eip2333(_key, master.Key, childIndex);
        }

        public readonly void FromBendian(scoped ReadOnlySpan<byte> inp)
        {
            if (inp.Length != 32)
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            blst_scalar_from_bendian(_key, inp);

            if (!blst_sk_check(_key))
            {
                throw new BlsException(ERROR.BADENCODING);
            }
        }
        public readonly void FromLendian(scoped ReadOnlySpan<byte> inp)
        {
            if (inp.Length != 32)
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            blst_scalar_from_lendian(_key, inp);

            if (!blst_sk_check(_key))
            {
                throw new BlsException(ERROR.BADENCODING);
            }
        }

        public readonly byte[] ToBendian()
        {
            byte[] ret = new byte[32];
            blst_bendian_from_scalar(ret, _key);
            return ret;
        }
        public readonly byte[] ToLendian()
        {
            byte[] ret = new byte[32];
            blst_lendian_from_scalar(ret, _key);
            return ret;
        }
    }

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_scalar_from_be_bytes(Span<byte> ret, ReadOnlySpan<byte> inp,
                                                                   size_t inp_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_scalar_from_le_bytes(Span<byte> ret, ReadOnlySpan<byte> inp,
                                                                   size_t inp_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_sk_add_n_check(Span<byte> ret, ReadOnlySpan<byte> a,
                                                             ReadOnlySpan<byte> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_sk_sub_n_check(Span<byte> ret, ReadOnlySpan<byte> a,
                                                             ReadOnlySpan<byte> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_sk_mul_n_check(Span<byte> ret, ReadOnlySpan<byte> a,
                                                             ReadOnlySpan<byte> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_sk_inverse(Span<byte> ret, ReadOnlySpan<byte> a);

    public readonly ref struct Scalar
    {
        public readonly ReadOnlySpan<byte> Val { get => _val; }
        private readonly Span<byte> _val;

        public Scalar(Span<byte> val)
        {
            if (val.Length < 32)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _val = val[..32];
        }

        public Scalar() : this(new byte[32])
        {}

        public Scalar(ReadOnlySpan<byte> inp, ByteOrder order = ByteOrder.BigEndian) : this()
        {
            switch (order)
            {
                case ByteOrder.BigEndian: FromBendian(inp); break;
                case ByteOrder.LittleEndian: FromLendian(inp); break;
            }
        }
        private Scalar(Scalar orig) : this() { orig._val.CopyTo(_val); }

        public readonly Scalar Dup() => new(this);

        public readonly void FromBendian(ReadOnlySpan<byte> inp)
        {
            blst_scalar_from_be_bytes(_val, inp, (size_t)inp.Length);
        }
        public readonly void FromLendian(ReadOnlySpan<byte> inp)
        {
            blst_scalar_from_le_bytes(_val, inp, (size_t)inp.Length);
        }

        public readonly byte[] ToBendian()
        {
            byte[] ret = new byte[32];
            blst_bendian_from_scalar(ret, _val);
            return ret;
        }
        public readonly byte[] ToLendian()
        {
            byte[] ret = new byte[32];
            blst_lendian_from_scalar(ret, _val);
            return ret;
        }

        public readonly Scalar Add(SecretKey a)
        {
            if (!blst_sk_add_n_check(_val, _val, a.Key))
            {
                throw new BlsException(ERROR.BADSCALAR);
            }
            return this;
        }
        public readonly Scalar Add(Scalar a)
        {
            if (!blst_sk_add_n_check(_val, _val, a._val))
            {
                throw new BlsException(ERROR.BADSCALAR);
            }
            return this;
        }
        public readonly Scalar Sub(Scalar a)
        {
            if (!blst_sk_sub_n_check(_val, _val, a._val))
            {
                throw new BlsException(ERROR.BADSCALAR);
            }
            return this;
        }
        public readonly Scalar Mul(Scalar a)
        {
            if (!blst_sk_mul_n_check(_val, _val, a._val))
            {
                throw new BlsException(ERROR.BADSCALAR);
            }
            return this;
        }
        public readonly Scalar Inverse()
        { blst_sk_inverse(_val, _val); return this; }

        public static Scalar operator +(Scalar a, Scalar b)
            => a.Dup().Add(b);
        public static Scalar operator -(Scalar a, Scalar b)
            => a.Dup().Sub(b);
        public static Scalar operator *(Scalar a, Scalar b)
            => a.Dup().Mul(b);
        public static Scalar operator /(Scalar a, Scalar b)
            => b.Dup().Inverse().Mul(a);
    }

    private const int P1_COMPRESSED_SZ = 384 / 8;
    private const int P2_COMPRESSED_SZ = 2 * P1_COMPRESSED_SZ;


    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_p1_affine_sizeof();

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_p1_deserialize(Span<long> ret, ReadOnlySpan<byte> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_affine_serialize(Span<byte> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_affine_compress(Span<byte> ret, ReadOnlySpan<long> inp);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_to_affine(Span<long> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_affine_on_curve(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_affine_in_g1(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_affine_is_inf(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_affine_is_equal(ReadOnlySpan<long> a, ReadOnlySpan<long> b);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial IntPtr blst_p1_generator();

    // [LibraryImport(LibraryName)]
    // [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    // static private partial ERROR blst_core_verify_pk_in_g2(ReadOnlySpan<long> pk, ReadOnlySpan<long> sig,
    //                                               [MarshalAs(UnmanagedType.Bool)] bool hash_or_encode,
    //                                               ReadOnlySpan<byte> msg, size_t msg_len,
    //                                               ReadOnlySpan<byte> dst, size_t dst_len,
    //                                               ReadOnlySpan<byte> aug, size_t aug_len);

    public readonly ref struct P1Affine
    {
        public readonly ReadOnlySpan<long> Point { get => _point; }
        public static int Sz { get => _sz; }
        private readonly Span<long> _point;
        private static readonly int _sz = (int)blst_p1_affine_sizeof() / sizeof(long);

        public P1Affine(P1Affine p)
        {
            _point = new long[Sz];
            p._point.CopyTo(_point);
        }

        public P1Affine(Span<long> p)
        {
            if (p.Length < Sz)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _point = p[..Sz];
        }

        public P1Affine()
        {
            _point = new long[Sz];
        }

        public P1Affine(scoped ReadOnlySpan<byte> inp) : this()
            => Decode(inp);

        public readonly void Zero()
            => _point.Clear();
        public void Decode(scoped ReadOnlySpan<byte> inp)
        {
            int len = inp.Length;
            if (len == 0 || len != ((inp[0] & 0x80) == 0x80 ? P1_COMPRESSED_SZ
                                                          : 2 * P1_COMPRESSED_SZ))
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            ERROR err = blst_p1_deserialize(_point, inp);
            if (err != ERROR.SUCCESS)
            {
                throw new BlsException(err);
            }
        }
        public P1Affine(P1 jacobian) : this()
            => blst_p1_to_affine(_point, jacobian.Point);

        public P1Affine Dup() => new(this);
        public P1 ToJacobian() => new(this);
        public byte[] Serialize()
        {
            byte[] ret = new byte[2 * P1_COMPRESSED_SZ];
            blst_p1_affine_serialize(ret, _point);
            return ret;
        }
        public byte[] Compress()
        {
            byte[] ret = new byte[P1_COMPRESSED_SZ];
            blst_p1_affine_compress(ret, _point);
            return ret;
        }

        public bool OnCurve()
            => blst_p1_affine_on_curve(_point);
        public bool InGroup()
            => blst_p1_affine_in_g1(_point);
        public bool IsInf()
            => blst_p1_affine_is_inf(_point);
        public bool IsEqual(P1Affine p)
            => blst_p1_affine_is_equal(_point, p._point);

        //         ERROR core_verify(P2_Affine pk, bool hash_or_encode,
        // #pragma warning disable CS8625 // Cannot convert null literal to non-nullable reference type.
        //                           byte[] msg, string DST = "", byte[] aug = null)
        // #pragma warning restore CS8625 // Cannot convert null literal to non-nullable reference type.
        //         {
        //             byte[] dst = Encoding.UTF8.GetBytes(DST);
        //             return blst_core_verify_pk_in_g2(pk.point, point,
        //                                              hash_or_encode,
        //                                              msg, (size_t)msg.Length,
        //                                              dst, (size_t)dst.Length,
        //                                              aug, (size_t)(aug != null ? aug.Length : 0));
        //         }

        public static P1Affine Generator()
        {
            long[] res = new long[Sz];
            return Generator(res);
        }

        public unsafe static P1Affine Generator(Span<long> p)
        {
            int s = (int)blst_p1_affine_sizeof();
            fixed (long* dest = p)
            {
                Buffer.MemoryCopy((byte*)blst_p1_generator(), dest, s, s);
            }
            return new(p);
        }
    }

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_fp_from_bendian(Span<long> ret, ReadOnlySpan<byte> a);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_p1_sizeof();
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_serialize(Span<byte> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_compress(Span<byte> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_from_affine(Span<long> ret, ReadOnlySpan<long> inp);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_on_curve(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_in_g1(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_is_inf(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p1_is_equal(ReadOnlySpan<long> a, ReadOnlySpan<long> b);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_sk_to_pk_in_g1(Span<long> ret, ReadOnlySpan<byte> SK);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_map_to_g1(Span<long> ret, ReadOnlySpan<long> u, ReadOnlySpan<long> v);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_encode_to_g1(Span<long> ret, ReadOnlySpan<byte> msg, size_t msg_len,
                                             ReadOnlySpan<byte> dst, size_t dst_len,
                                             ReadOnlySpan<byte> aug, size_t aug_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_hash_to_g1(Span<long> ret, ReadOnlySpan<byte> msg, size_t msg_len,
                                           ReadOnlySpan<byte> dst, size_t dst_len,
                                           ReadOnlySpan<byte> aug, size_t aug_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_sign_pk_in_g2(Span<long> ret, ReadOnlySpan<long> hash, ReadOnlySpan<byte> SK);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_mult(Span<long> ret, ReadOnlySpan<long> a,
                                        ReadOnlySpan<byte> scalar, size_t nbits);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_cneg(Span<long> ret, [MarshalAs(UnmanagedType.Bool)] bool cbit);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_add_or_double(Span<long> ret, ReadOnlySpan<long> a, ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_add_or_double_affine(Span<long> ret, ReadOnlySpan<long> a,
                                                        ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p1_double(Span<long> ret, ReadOnlySpan<long> a);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_p1s_mult_pippenger_scratch_sizeof(size_t npoints);
    // void blst_p1s_mult_pippenger(blst_p1 *ret, const blst_p1_affine *const points[],
    //                          size_t npoints, const byte *const scalars[],
    //                          size_t nbits, limb_t *scratch);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static unsafe partial void blst_p1s_mult_pippenger(Span<long> ret, long** points,
        size_t npoints, byte** scalars, size_t nbits, long* scratch);

    // void blst_p1s_to_affine(blst_p1_affine dst[], const blst_p1 *const points[],
    //                     size_t npoints);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static unsafe partial void blst_p1s_to_affine(Span<long> dst, long** points, size_t npoints);

    public readonly ref struct P1
    {
        public readonly ReadOnlySpan<long> Point { get => _point; }
        public static int Sz { get => _sz; }
        private readonly Span<long> _point;
        private static readonly int _sz = (int)blst_p1_sizeof() / sizeof(long);

        public P1(P1 p)
        {
            _point = new long[Sz];
            p._point.CopyTo(_point);
        }

        public P1(Span<long> p)
        {
            if (p.Length < Sz)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _point = p[..Sz];
        }

        public P1()
        {
            _point = new long[Sz];
        }

        public P1(SecretKey sk) : this()
            => FromSk(sk);

        public void FromSk(SecretKey sk)
        { blst_sk_to_pk_in_g1(_point, sk.Key); }

        public P1(scoped ReadOnlySpan<byte> inp) : this()
            => Decode(inp);

        public readonly void Zero()
            => _point.Clear();
        public void Decode(scoped ReadOnlySpan<byte> inp)
        {
            int len = inp.Length;
            if (len == 0 || len != ((inp[0] & 0x80) == 0x80 ? P1_COMPRESSED_SZ
                                                          : 2 * P1_COMPRESSED_SZ))
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            if (len == 2 * P1_COMPRESSED_SZ)
            {
                blst_fp_from_bendian(_point, inp[..48]);
                blst_fp_from_bendian(_point[6..], inp[48..]);
            }
            else
            {
                ERROR err = blst_p1_deserialize(_point, inp);
                if (err != ERROR.SUCCESS)
                    throw new BlsException(err);
            }

            blst_p1_from_affine(_point, _point);
        }

        public void Decode(ReadOnlySpan<byte> fp1, ReadOnlySpan<byte> fp2)
        {
            if (fp1.Length != 48 || fp2.Length != 48)
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            blst_fp_from_bendian(_point, fp1);
            blst_fp_from_bendian(_point[6..], fp2);
            blst_p1_from_affine(_point, _point);
        }

        public P1(P1Affine affine) : this()
        { blst_p1_from_affine(_point, affine.Point); }

        public readonly P1 Dup() => new(this);
        public readonly P1Affine ToAffine() => new(this);
        public readonly byte[] Serialize()
        {
            byte[] ret = new byte[2 * P1_COMPRESSED_SZ];
            blst_p1_serialize(ret, _point);
            return ret;
        }
        public readonly byte[] Compress()
        {
            byte[] ret = new byte[P1_COMPRESSED_SZ];
            blst_p1_compress(ret, _point);
            return ret;
        }

        public readonly bool OnCurve()
            => blst_p1_on_curve(_point);
        public readonly bool InGroup()
            => blst_p1_in_g1(_point);
        public readonly bool IsInf()
            => blst_p1_is_inf(_point);
        public readonly bool IsEqual(P1 p)
            => blst_p1_is_equal(_point, p._point);

        public readonly P1 MapTo(ReadOnlySpan<byte> fp)
        {
            long[] u = new long[6];
            blst_fp_from_bendian(u, fp);
            blst_map_to_g1(_point, u, null);
            return this;
        }
        public readonly P1 HashTo(scoped ReadOnlySpan<byte> msg, ReadOnlySpan<byte> DST = default, ReadOnlySpan<byte> aug = default)
        {
            blst_hash_to_g1(_point, msg, (size_t)msg.Length,
                                    DST, (size_t)DST.Length,
                                    aug, (size_t)(aug != null ? aug.Length : 0));
            return this;
        }
        public readonly P1 EncodeTo(scoped ReadOnlySpan<byte> msg, ReadOnlySpan<byte> DST = default, ReadOnlySpan<byte> aug = default)
        {
            blst_encode_to_g1(_point, msg, (size_t)msg.Length,
                                      DST, (size_t)DST.Length,
                                      aug, (size_t)(aug != null ? aug.Length : 0));
            return this;
        }

        public readonly P1 SignWith(SecretKey sk)
        { blst_sign_pk_in_g2(_point, _point, sk.Key); return this; }
        public readonly P1 SignWith(Scalar scalar)
        { blst_sign_pk_in_g2(_point, _point, scalar.Val); return this; }

        public readonly void Aggregate(P1Affine inp)
        {
            if (blst_p1_affine_in_g1(inp.Point))
            {
                blst_p1_add_or_double_affine(_point, _point, inp.Point);
            }
            else
            {
                throw new BlsException(ERROR.POINTNOTINGROUP);
            }
        }

        public readonly P1 Mult(scoped ReadOnlySpan<byte> scalar)
        {
            blst_p1_mult(_point, _point, scalar, (size_t)(scalar.Length * 8));
            return this;
        }
        public readonly P1 Mult(Scalar scalar)
        {
            blst_p1_mult(_point, _point, scalar.Val, 255);
            return this;
        }

        private readonly byte[] PrepareMult(in BigInteger scalar)
        {
            byte[] val;
            if (scalar.Sign < 0)
            {
                val = BigInteger.Negate(scalar).ToByteArray();
                blst_p1_cneg(_point, true);
            }
            else
            {
                val = scalar.ToByteArray();
            }
            return val;
        }
        private static size_t GetSize(ReadOnlySpan<byte> val)
        {
            int len = val.Length;
            if (val[len - 1] == 0) len--;
            return (size_t)len;
        }
        public readonly P1 Mult(in BigInteger scalar)
        {
            byte[] val = PrepareMult(scalar);
            size_t len = GetSize(val);
            blst_p1_mult(_point, _point, val, len * 8);
            return this;
        }

        private readonly void PrepareMult(ref Scalar scalar)
        {
            byte[] val = PrepareMult(new(scalar.ToBendian(), true, true));
            scalar.FromBendian(val);
        }

        private readonly unsafe P1 MultiMultRawAffines(long* rawAffinesPtr, scoped Span<byte> rawScalars, int npoints)
        {
            fixed (byte* rawScalarsPtr = rawScalars)
            {
                long*[] rawAffinesWrapper = [rawAffinesPtr, null];
                byte*[] rawScalarsWrapper = [rawScalarsPtr, null];

                size_t scratchSize = blst_p1s_mult_pippenger_scratch_sizeof((size_t)npoints) / sizeof(long);
                Span<long> scratch = new long[(int)scratchSize];

                fixed (long** rawAffinesWrapperPtr = rawAffinesWrapper)
                fixed (byte** rawScalarsWrapperPtr = rawScalarsWrapper)
                fixed (long* scratchPtr = scratch)
                    blst_p1s_mult_pippenger(_point, rawAffinesWrapperPtr, (size_t)npoints, rawScalarsWrapperPtr, 256, scratchPtr);
            }
            return this;
        }

        // points at infinity should be filtered out, scalars little endian
        public readonly unsafe P1 MultiMult(scoped Span<long> rawPoints, scoped Span<byte> rawScalars, int npoints)
        {
            Span<long> rawAffines = new long[npoints * 12];

            fixed (long* rawPointsPtr = rawPoints)
            {
                long*[] rawPointsWrapper = [rawPointsPtr, null];

                fixed (long** rawPointsWrapperPtr = rawPointsWrapper)
                    blst_p1s_to_affine(rawAffines, rawPointsWrapperPtr, (size_t)npoints);
            }

            fixed (long* rawAffinesPtr = rawAffines)
                return MultiMultRawAffines(rawAffinesPtr, rawScalars, npoints);
        }
        public readonly P1 Cneg(bool flag) { blst_p1_cneg(_point, flag); return this; }
        public readonly P1 Neg() { blst_p1_cneg(_point, true); return this; }
        public readonly P1 Add(P1 a)
        { blst_p1_add_or_double(_point, _point, a._point); return this; }
        public readonly P1 Add(P1Affine a)
        { blst_p1_add_or_double_affine(_point, _point, a.Point); return this; }
        public readonly P1 Dbl()
        { blst_p1_double(_point, _point); return this; }

        public static P1 Generator()
        {
            long[] res = new long[Sz];
            return Generator(res);
        }

        public unsafe static P1 Generator(Span<long> p)
        {
            int s = (int)blst_p1_sizeof();
            fixed (long* dest = p)
            {
                Buffer.MemoryCopy((byte*)blst_p1_generator(), dest, s, s);
            }
            return new(p);
        }
    }

    public static P1 G1() => P1.Generator();

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_aggregated_in_g1(Span<long> fp12, ReadOnlySpan<long> p);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_pairing_aggregate_pk_in_g1(Span<long> fp12,
                                    ReadOnlySpan<long> pk, ReadOnlySpan<long> sig,
                                    ReadOnlySpan<byte> msg, size_t msg_len,
                                    ReadOnlySpan<byte> aug, size_t aug_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_pairing_mul_n_aggregate_pk_in_g1(Span<long> fp12,
                                    ReadOnlySpan<long> pk, ReadOnlySpan<long> sig,
                                    ReadOnlySpan<byte> scalar, size_t nbits,
                                    ReadOnlySpan<byte> msg, size_t msg_len,
                                    ReadOnlySpan<byte> aug, size_t aug_len);


    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_p2_affine_sizeof();

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_p2_deserialize(Span<long> ret, ReadOnlySpan<byte> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_affine_serialize(Span<byte> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_affine_compress(Span<byte> ret, ReadOnlySpan<long> inp);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_to_affine(Span<long> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_affine_on_curve(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_affine_in_g2(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_affine_is_inf(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_affine_is_equal(ReadOnlySpan<long> a, ReadOnlySpan<long> b);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial IntPtr blst_p2_generator();

    // [LibraryImport(LibraryName)]
    // [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    // static private partial ERROR blst_core_verify_pk_in_g1(ReadOnlySpan<long> pk, ReadOnlySpan<long> sig,
    //                                               [MarshalAs(UnmanagedType.Bool)] bool hash_or_encode,
    //                                               ReadOnlySpan<byte> msg, size_t msg_len,
    //                                               ReadOnlySpan<byte> dst, size_t dst_len,
    //                                               ReadOnlySpan<byte> aug, size_t aug_len);

    public readonly ref struct P2Affine
    {

        public readonly ReadOnlySpan<long> Point { get => _point; }
        public static int Sz { get => _sz; }
        private readonly Span<long> _point;
        private static readonly int _sz = (int)blst_p2_affine_sizeof() / sizeof(long);

        public P2Affine(P2Affine p)
        {
            _point = new long[Sz];
            p._point.CopyTo(_point);
        }

        public P2Affine(Span<long> p)
        {
            if (p.Length < Sz)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _point = p[..Sz];
        }

        public P2Affine()
        {
            _point = new long[Sz];
        }

        public P2Affine(scoped ReadOnlySpan<byte> inp) : this()
            => Decode(inp);

        public readonly void Zero()
            => _point.Clear();
        public void Decode(scoped ReadOnlySpan<byte> inp)
        {
            int len = inp.Length;
            if (len == 0 || len != ((inp[0] & 0x80) == 0x80 ? P2_COMPRESSED_SZ
                                                          : 2 * P2_COMPRESSED_SZ))
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            ERROR err = blst_p2_deserialize(_point, inp);
            if (err != ERROR.SUCCESS)
            {
                throw new BlsException(err);
            }
        }

        public P2Affine(P2 jacobian) : this()
        { blst_p2_to_affine(_point, jacobian.Point); }

        public readonly P2Affine Dup() => new(this);
        public readonly P2 ToJacobian() => new(this);
        public readonly byte[] Serialize()
        {
            byte[] ret = new byte[2 * P2_COMPRESSED_SZ];
            blst_p2_affine_serialize(ret, _point);
            return ret;
        }
        public readonly byte[] Compress()
        {
            byte[] ret = new byte[P2_COMPRESSED_SZ];
            blst_p2_affine_compress(ret, _point);
            return ret;
        }

        public readonly bool OnCurve()
            => blst_p2_affine_on_curve(_point);
        public readonly bool InGroup()
            => blst_p2_affine_in_g2(_point);
        public readonly bool IsInf()
            => blst_p2_affine_is_inf(_point);
        public readonly bool IsEqual(P2Affine p)
            => blst_p2_affine_is_equal(_point, p._point);

        //         readonly ERROR core_verify(P1Affine pk, bool hash_or_encode,
        // #pragma warning disable CS8625 // Cannot convert null literal to non-nullable reference type.
        //                           byte[] msg, string DST = "", byte[] aug = null)
        // #pragma warning restore CS8625 // Cannot convert null literal to non-nullable reference type.
        //         {
        //             byte[] dst = Encoding.UTF8.GetBytes(DST);
        //             return blst_core_verify_pk_in_g1(pk.Point, Point,
        //                                              hash_or_encode,
        //                                              msg, (size_t)msg.Length,
        //                                              dst, (size_t)dst.Length,
        //                                              aug, (size_t)(aug != null ? aug.Length : 0));
        //         }

        public static P2Affine Generator()
        {
            long[] res = new long[Sz];
            return Generator(res);
        }

        public unsafe static P2Affine Generator(Span<long> p)
        {
            int s = (int)blst_p2_affine_sizeof();
            fixed (long* dest = p)
            {
                Buffer.MemoryCopy((byte*)blst_p2_generator(), dest, s, s);
            }
            return new(p);
        }
    }

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_p2_sizeof();
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_serialize(Span<byte> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_compress(Span<byte> ret, ReadOnlySpan<long> inp);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_from_affine(Span<long> ret, ReadOnlySpan<long> inp);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_on_curve(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_in_g2(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_is_inf(ReadOnlySpan<long> point);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_p2_is_equal(ReadOnlySpan<long> a, ReadOnlySpan<long> b);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_sk_to_pk_in_g2(Span<long> ret, ReadOnlySpan<byte> SK);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_map_to_g2(Span<long> ret, ReadOnlySpan<long> u, ReadOnlySpan<long> v);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_encode_to_g2(Span<long> ret, ReadOnlySpan<byte> msg, size_t msg_len,
                                             ReadOnlySpan<byte> dst, size_t dst_len,
                                             ReadOnlySpan<byte> aug, size_t aug_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_hash_to_g2(Span<long> ret, ReadOnlySpan<byte> msg, size_t msg_len,
                                           ReadOnlySpan<byte> dst, size_t dst_len,
                                           ReadOnlySpan<byte> aug, size_t aug_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_sign_pk_in_g1(Span<long> ret, ReadOnlySpan<long> hash, ReadOnlySpan<byte> SK);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_mult(Span<long> ret, ReadOnlySpan<long> a,
                                        ReadOnlySpan<byte> scalar, size_t nbits);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_cneg(Span<long> ret, [MarshalAs(UnmanagedType.Bool)] bool cbit);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_add_or_double(Span<long> ret, ReadOnlySpan<long> a, ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_add_or_double_affine(Span<long> ret, ReadOnlySpan<long> a,
                                                        ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_p2_double(Span<long> ret, ReadOnlySpan<long> a);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_p2s_mult_pippenger_scratch_sizeof(size_t npoints);
    // void blst_p2s_mult_pippenger(blst_p2 *ret, const blst_p2_affine *const points[],
    //                          size_t npoints, const byte *const scalars[],
    //                          size_t nbits, limb_t *scratch);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static unsafe partial void blst_p2s_mult_pippenger(Span<long> ret, long** points,
        size_t npoints, byte** scalars, size_t nbits, long* scratch);

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static unsafe partial void blst_p2s_to_affine(Span<long> dst, long** points, size_t npoints);

    public readonly ref struct P2
    {
        public readonly ReadOnlySpan<long> Point { get => _point; }
        public static int Sz { get => _sz; }
        private readonly Span<long> _point;
        private static readonly int _sz = (int)blst_p2_sizeof() / sizeof(long);

        public P2(P2 p)
        {
            _point = new long[Sz];
            p._point.CopyTo(_point);
        }

        public P2(Span<long> p)
        {
            if (p.Length < Sz)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _point = p[..Sz];
        }

        public P2()
        {
            _point = new long[Sz];
        }

        public P2(SecretKey sk) : this()
        { blst_sk_to_pk_in_g2(_point, sk.Key); }

        public P2(scoped ReadOnlySpan<byte> inp) : this()
            => Decode(inp);

        public P2(P2Affine affine) : this()
        { blst_p2_from_affine(_point, affine.Point); }

        public readonly void Zero()
            => _point.Clear();
        public void Decode(scoped ReadOnlySpan<byte> inp)
        {
            int len = inp.Length;
            if (len == 0 || len != ((inp[0] & 0x80) == 0x80 ? P2_COMPRESSED_SZ
                                                          : 2 * P2_COMPRESSED_SZ))
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            if (len == 2 * P2_COMPRESSED_SZ)
            {
                blst_fp_from_bendian(_point, inp[48..]);
                blst_fp_from_bendian(_point[6..], inp[..48]);
                blst_fp_from_bendian(_point[12..], inp[144..]);
                blst_fp_from_bendian(_point[18..], inp[96..]);
            }
            else
            {
                ERROR err = blst_p2_deserialize(_point, inp);
                if (err != ERROR.SUCCESS)
                    throw new BlsException(err);
            }

            blst_p2_from_affine(_point, _point);
        }

        public void Decode(ReadOnlySpan<byte> fp1, ReadOnlySpan<byte> fp2, ReadOnlySpan<byte> fp3, ReadOnlySpan<byte> fp4)
        {
            if (fp1.Length != 48 || fp2.Length != 48 || fp3.Length != 48 || fp4.Length != 48)
            {
                throw new BlsException(ERROR.BADENCODING);
            }

            blst_fp_from_bendian(_point, fp1);
            blst_fp_from_bendian(_point[6..], fp2);
            blst_fp_from_bendian(_point[12..], fp3);
            blst_fp_from_bendian(_point[18..], fp4);
            blst_p2_from_affine(_point, _point);
        }

        public readonly P2 Dup() => new(this);
        public readonly P2Affine ToAffine() => new(this);
        public readonly byte[] Serialize()
        {
            byte[] ret = new byte[2 * P2_COMPRESSED_SZ];
            blst_p2_serialize(ret, _point);
            return ret;
        }
        public readonly byte[] Compress()
        {
            byte[] ret = new byte[P2_COMPRESSED_SZ];
            blst_p2_compress(ret, _point);
            return ret;
        }

        public readonly bool OnCurve()
            => blst_p2_on_curve(_point);
        public readonly bool InGroup()
            => blst_p2_in_g2(_point);
        public readonly bool IsInf()
            => blst_p2_is_inf(_point);
        public readonly bool IsEqual(P2 p)
            => blst_p2_is_equal(_point, p._point);

        public readonly unsafe P2 MapTo(scoped ReadOnlySpan<byte> c0, scoped ReadOnlySpan<byte> c1)
        {
            Span<long> u0 = stackalloc long[6];
            Span<long> u1 = stackalloc long[6];

            blst_fp_from_bendian(u0, c0);
            blst_fp_from_bendian(u1, c1);

            Span<long> u = [.. u0, .. u1];

            blst_map_to_g2(_point, u, null);
            return this;
        }
        public readonly P2 HashTo(scoped ReadOnlySpan<byte> msg, scoped ReadOnlySpan<byte> DST = default, scoped ReadOnlySpan<byte> aug = default)
        {
            blst_hash_to_g2(_point, msg, (size_t)msg.Length,
                                    DST, (size_t)DST.Length,
                                    aug, (size_t)(aug != null ? aug.Length : 0));
            return this;
        }
        public readonly P2 EncodeTo(scoped ReadOnlySpan<byte> msg, scoped ReadOnlySpan<byte> DST = default, scoped ReadOnlySpan<byte> aug = default)
        {
            blst_encode_to_g2(_point, msg, (size_t)msg.Length,
                                      DST, (size_t)DST.Length,
                                      aug, (size_t)(aug != null ? aug.Length : 0));
            return this;
        }

        public readonly P2 SignWith(SecretKey sk)
        { blst_sign_pk_in_g1(_point, _point, sk.Key); return this; }
        public readonly P2 SignWith(Scalar scalar)
        { blst_sign_pk_in_g1(_point, _point, scalar.Val); return this; }

        public readonly void Aggregate(P2Affine inp)
        {
            if (blst_p2_affine_in_g2(inp.Point))
            {
                blst_p2_add_or_double_affine(_point, _point, inp.Point);
            }
            else
            {
                throw new BlsException(ERROR.POINTNOTINGROUP);
            }
        }

        public readonly P2 Mult(scoped ReadOnlySpan<byte> scalar)
        {
            blst_p2_mult(_point, _point, scalar, (size_t)(scalar.Length * 8));
            return this;
        }
        public readonly P2 Mult(Scalar scalar)
        {
            blst_p2_mult(_point, _point, scalar.Val, 255);
            return this;
        }
        public readonly P2 Mult(in BigInteger scalar)
        {
            byte[] val;
            if (scalar.Sign < 0)
            {
                val = BigInteger.Negate(scalar).ToByteArray();
                blst_p2_cneg(_point, true);
            }
            else
            {
                val = scalar.ToByteArray();
            }
            int len = val.Length;
            if (val[len - 1] == 0) len--;
            blst_p2_mult(_point, _point, val, (size_t)(len * 8));
            return this;
        }
        private readonly unsafe P2 MultiMultRawAffines(long* rawAffinesPtr, scoped Span<byte> rawScalars, int npoints)
        {
            fixed (byte* rawScalarsPtr = rawScalars)
            {
                long*[] rawAffinesWrapper = [rawAffinesPtr, null];
                byte*[] rawScalarsWrapper = [rawScalarsPtr, null];

                size_t scratchSize = blst_p2s_mult_pippenger_scratch_sizeof((size_t)npoints) / sizeof(long);
                Span<long> scratch = new long[(int)scratchSize];

                fixed (long** rawAffinesWrapperPtr = rawAffinesWrapper)
                fixed (byte** rawScalarsWrapperPtr = rawScalarsWrapper)
                fixed (long* scratchPtr = scratch)
                    blst_p2s_mult_pippenger(_point, rawAffinesWrapperPtr, (size_t)npoints, rawScalarsWrapperPtr, 256, scratchPtr);
            }
            return this;
        }

        // points at infinity should be filtered out, scalars little endian
        public readonly unsafe P2 MultiMult(scoped Span<long> rawPoints, scoped Span<byte> rawScalars, int npoints)
        {
            Span<long> rawAffines = new long[npoints * 24];

            fixed (long* rawPointsPtr = rawPoints)
            {
                long*[] rawPointsWrapper = [rawPointsPtr, null];

                fixed (long** rawPointsWrapperPtr = rawPointsWrapper)
                    blst_p2s_to_affine(rawAffines, rawPointsWrapperPtr, (size_t)npoints);
            }

            fixed (long* rawAffinesPtr = rawAffines)
                return MultiMultRawAffines(rawAffinesPtr, rawScalars, npoints);
        }
        public readonly P2 Cneg(bool flag) { blst_p2_cneg(_point, flag); return this; }
        public readonly P2 Neg() { blst_p2_cneg(_point, true); return this; }
        public readonly P2 Add(P2 a)
        { blst_p2_add_or_double(_point, _point, a.Point); return this; }
        public readonly P2 Add(P2Affine a)
        { blst_p2_add_or_double_affine(_point, _point, a.Point); return this; }
        public readonly P2 Dbl()
        { blst_p2_double(_point, _point); return this; }

        public static P2 Generator()
        {
            long[] res = new long[Sz];
            return Generator(res);
        }

        public unsafe static P2 Generator(Span<long> p)
        {
            int s = (int)blst_p2_sizeof();
            fixed (long* dest = p)
            {
                Buffer.MemoryCopy((byte*)blst_p2_generator(), dest, s, s);
            }
            return new(p);
        }
    }

    public static P2 G2() => P2.Generator();

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_aggregated_in_g2(Span<long> fp12, ReadOnlySpan<long> p);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_pairing_aggregate_pk_in_g2(Span<long> fp12,
                                    ReadOnlySpan<long> pk, ReadOnlySpan<long> sig,
                                    ReadOnlySpan<byte> msg, size_t msg_len,
                                    ReadOnlySpan<byte> aug, size_t aug_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_pairing_mul_n_aggregate_pk_in_g2(Span<long> fp12,
                                    ReadOnlySpan<long> pk, ReadOnlySpan<long> sig,
                                    ReadOnlySpan<byte> scalar, size_t nbits,
                                    ReadOnlySpan<byte> msg, size_t msg_len,
                                    ReadOnlySpan<byte> aug, size_t aug_len);


    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_fp12_sizeof();
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_miller_loop(Span<long> fp12, ReadOnlySpan<long> q,
                                                           ReadOnlySpan<long> p);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_fp12_is_one(ReadOnlySpan<long> fp12);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_fp12_is_equal(ReadOnlySpan<long> a, ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_fp12_sqr(Span<long> ret, ReadOnlySpan<long> a);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_fp12_mul(Span<long> ret, ReadOnlySpan<long> a,
                                                       ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_final_exp(Span<long> ret, ReadOnlySpan<long> a);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_fp12_finalverify(ReadOnlySpan<long> a, ReadOnlySpan<long> b);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial IntPtr blst_fp12_one();
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_fp12_in_group(ReadOnlySpan<long> a);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_bendian_from_fp12(Span<byte> ret, ReadOnlySpan<long> a);

    public readonly ref struct PT
    {
        public readonly ReadOnlySpan<long> Fp12 { get => _fp12; }
        public static int Sz { get => _sz; }
        private readonly Span<long> _fp12;
        private static readonly int _sz = (int)blst_fp12_sizeof() / sizeof(long);

        public PT(PT orig)
        {
            _fp12 = new long[Sz];
            orig._fp12.CopyTo(_fp12);
        }

        public PT(Span<long> p)
        {
            if (p.Length < Sz)
            {
                throw new BlsException(ERROR.WRONGSIZE);
            }
            _fp12 = p[..Sz];
        }

        public PT()
        {
            _fp12 = new long[Sz];
        }

        public PT(P1Affine p) : this()
        { blst_aggregated_in_g1(_fp12, p.Point); }
        public PT(P1 p) : this()
        { blst_aggregated_in_g1(_fp12, new P1Affine(p).Point); }
        public PT(P2Affine q) : this()
        { blst_aggregated_in_g2(_fp12, q.Point); }
        public PT(P2 q) : this()
        { blst_aggregated_in_g2(_fp12, new P2Affine(q).Point); }
        public PT(P2Affine q, P1Affine p) : this()
            => MillerLoop(q, p);
        public PT(P1Affine p, P2Affine q) : this(q, p) { }
        public PT(P2 q, P1 p) : this()
            => MillerLoop(q, p);
        public PT(P1 p, P2 q) : this(q, p) { }

        public void MillerLoop(P2Affine q, P1Affine p)
        { blst_miller_loop(_fp12, q.Point, p.Point); }
        public void MillerLoop(P2 q, P1 p)
            => MillerLoop(q.ToAffine(), p.ToAffine());
        public readonly PT Dup() => new(this);
        public readonly bool IsOne()
            => blst_fp12_is_one(_fp12);
        public readonly bool IsEqual(PT p)
            => blst_fp12_is_equal(_fp12, p._fp12);
        public readonly PT Sqr() { blst_fp12_sqr(_fp12, _fp12); return this; }
        public readonly PT Mul(PT p) { blst_fp12_mul(_fp12, _fp12, p._fp12); return this; }
        public readonly PT FinalExp() { blst_final_exp(_fp12, _fp12); return this; }
        public readonly bool InGroup()
            => blst_fp12_in_group(_fp12);
        public readonly byte[] ToBendian()
        {
            byte[] ret = new byte[12 * P1_COMPRESSED_SZ];
            blst_bendian_from_fp12(ret, _fp12);
            return ret;
        }

        public static bool FinalVerify(PT gt1, PT gt2)
        { return blst_fp12_finalverify(gt1._fp12, gt2._fp12); }

        public static PT One()
        {
            long[] res = new long[Sz];
            return One(res);
        }

        public unsafe static PT One(Span<long> p)
        {
            int s = (int)blst_fp12_sizeof();
            fixed (long* dest = p)
            {
                Buffer.MemoryCopy((byte*)blst_fp12_one(), dest, s, s);
            }
            return new(p);
        }
    }

    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial size_t blst_pairing_sizeof();
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_pairing_init(Span<long> ctx, [MarshalAs(UnmanagedType.Bool)] bool hash_or_encode,
                                                 ref long dst, size_t dst_len);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_pairing_commit(Span<long> ctx);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial ERROR blst_pairing_merge(Span<long> ctx, ReadOnlySpan<long> ctx1);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    [return: MarshalAs(UnmanagedType.Bool)]
    static private partial bool blst_pairing_finalverify(ReadOnlySpan<long> ctx, ReadOnlySpan<long> sig);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial void blst_pairing_raw_aggregate(Span<long> ctx, ReadOnlySpan<long> q,
                                                          ReadOnlySpan<long> p);
    [LibraryImport(LibraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvCdecl)])]
    static private partial IntPtr blst_pairing_as_fp12(ReadOnlySpan<long> ctx);

    public readonly ref struct Pairing
    {
        public readonly ReadOnlySpan<long> Ctx { get => _ctx; }
        public static int Sz { get => _sz; }
        private readonly Span<long> _ctx;
        private static readonly int _sz = (int)blst_pairing_sizeof() / sizeof(long);

        public Pairing(bool hashOrEncode = false, scoped ReadOnlySpan<byte> DST = default)
        {
            int dst_len = DST.Length;
            int add_len = dst_len != 0 ? (dst_len + sizeof(long) - 1) / sizeof(long) : 1;

            Span<byte> dst = new byte[add_len * sizeof(long)];
            DST.CopyTo(dst);

            _ctx = new long[Sz + add_len];

            for (int i = 0; i < add_len; i++)
            {
                _ctx[Sz + i] = BitConverter.ToInt64(dst[(i * sizeof(long))..]);
            }

            blst_pairing_init(_ctx, hashOrEncode, ref _ctx[Sz], (size_t)dst_len);
        }

        public readonly ERROR Aggregate(P1Affine pk, P2Affine sig,
                                              ReadOnlySpan<byte> msg, ReadOnlySpan<byte> aug = default)
        {
            return blst_pairing_aggregate_pk_in_g1(_ctx, pk.Point,
                                    sig.Point,
                                    msg, (size_t)msg.Length,
                                    aug, (size_t)(aug != null ? aug.Length : 0));
        }
        public readonly ERROR Aggregate(P2Affine pk, P1Affine sig,
                                             ReadOnlySpan<byte> msg, ReadOnlySpan<byte> aug = default)
        {
            return blst_pairing_aggregate_pk_in_g2(_ctx, pk.Point,
                                    sig.Point,
                                    msg, (size_t)msg.Length,
                                    aug, (size_t)(aug != null ? aug.Length : 0));
        }
        public readonly ERROR MulNAggregate(P2Affine pk, P1Affine sig,
                                                   ReadOnlySpan<byte> scalar, int nbits,
                                                   ReadOnlySpan<byte> msg, ReadOnlySpan<byte> aug = default)
        {
            return blst_pairing_mul_n_aggregate_pk_in_g2(_ctx, pk.Point, sig.Point,
                                    scalar, (size_t)nbits,
                                    msg, (size_t)msg.Length,
                                    aug, (size_t)(aug != null ? aug.Length : 0));
        }
        public readonly ERROR MulNAggregate(P1Affine pk, P2Affine sig,
                                                   ReadOnlySpan<byte> scalar, int nbits,
                                                   ReadOnlySpan<byte> msg, ReadOnlySpan<byte> aug = default)
        {
            return blst_pairing_mul_n_aggregate_pk_in_g1(_ctx, pk.Point, sig.Point,
                                    scalar, (size_t)nbits,
                                    msg, (size_t)msg.Length,
                                    aug, (size_t)(aug != null ? aug.Length : 0));
        }

        public readonly void Commit() { blst_pairing_commit(_ctx); }
        public readonly void Merge(in Pairing a)
        {
            ERROR err = blst_pairing_merge(_ctx, a._ctx);
            if (err != ERROR.SUCCESS)
            {
                throw new BlsException(err);
            }
        }
        public readonly bool FinalVerify(PT sig)
        { return blst_pairing_finalverify(_ctx, sig.Fp12); }

        public readonly void RawAggregate(P2Affine q, P1Affine p)
        { blst_pairing_raw_aggregate(_ctx, q.Point, p.Point); }
        public void RawAggregate(P1Affine p, P2Affine q)
        { RawAggregate(q, p); }
        public readonly void RawAggregate(P2 q, P1 p)
        {
            blst_pairing_raw_aggregate(_ctx, new P2Affine(q).Point,
                                            new P1Affine(p).Point);
        }
        public void RawAggregate(P1 p, P2 q)
            => RawAggregate(q, p);
        public readonly PT AsFp12()
        {
            long[] res = new long[Sz];
            Marshal.Copy(blst_pairing_as_fp12(_ctx), res, 0, Sz);
            return new(res);
        }
    }
}
